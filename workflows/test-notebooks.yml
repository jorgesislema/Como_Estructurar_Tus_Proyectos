# plantillas/workflows/test-notebooks.yml
# ---------------------------------------
# Plantilla de Workflow de GitHub Actions para "Testear" Jupyter Notebooks
#
# Prop√≥sito: Asegurar que los notebooks en el repositorio se ejecutan sin errores.
#            Opcionalmente, verifica el formato y linting del c√≥digo en las celdas.
#            NO verifica la correcci√≥n de las salidas, solo la ejecuci√≥n exitosa.
#
# C√≥mo usar:
# 1. Crea la carpeta '.github/workflows/' en la ra√≠z de tu repositorio si no existe.
# 2. Copia este contenido a un archivo dentro de esa carpeta (ej: '.github/workflows/test-notebooks.yml').
# 3. Adapta las secciones marcadas con "[ADAPTAR]" a tu proyecto:
#    - Ramas y paths en el trigger 'on:'.
#    - Versi√≥n de Python.
#    - Comando de instalaci√≥n de dependencias.
#    - Lista de dependencias EXTRA necesarias para EJECUTAR los notebooks (jupyter, nbconvert, librer√≠as usadas).
#    - Ruta a la carpeta de notebooks ('notebooks/').
#    - Timeout para la ejecuci√≥n de notebooks.
#
# Herramientas Usadas:
# - nbconvert: Para ejecutar los notebooks.
# - nbqa (Opcional): Para correr linters/formatters (como Ruff, Black) en el c√≥digo de los notebooks.

name: üß™ Test Jupyter Notebooks

# --- Disparadores del Workflow ---
on:
  push:
    branches: [ "main", "develop" ] # [ADAPTAR] Ramas que disparan en push
    # Solo ejecutar si cambian notebooks o este workflow
    paths:
      - 'notebooks/**/*.ipynb' # [ADAPTAR] Ruta a tus notebooks
      - '.github/workflows/test-notebooks.yml'
  pull_request:
    branches: [ "main", "develop" ] # [ADAPTAR] Ramas objetivo para PRs
    paths:
      - 'notebooks/**/*.ipynb' # [ADAPTAR] Ruta a tus notebooks
      - '.github/workflows/test-notebooks.yml'
  # Permite ejecuci√≥n manual
  workflow_dispatch:

# --- Trabajos (Jobs) ---
jobs:
  execute_notebooks:
    name: Ejecutar Notebooks
    runs-on: ubuntu-latest # Ubuntu suele ser suficiente

    steps:
      # 1. Checkout del c√≥digo
      - name: Checkout c√≥digo fuente üõéÔ∏è
        uses: actions/checkout@v4

      # 2. Configurar Python
      - name: Configurar Python üêç
        uses: actions/setup-python@v5
        with:
          python-version: '3.10' # [ADAPTAR] Elige una versi√≥n relevante para tus notebooks
          # cache: 'pip' # Cache b√°sico de pip

      # 3. (Opcional) Cache de Dependencias (M√°s espec√≠fico)
      - name: Cache de dependencias pip ‚ö°
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles('**/requirements*.txt', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ matrix.python-version }}-
            ${{ runner.os }}-pip-
      # Comentario: Adapta si usas Poetry/Hatch para el cache

      # 4. Instalar Dependencias del Proyecto y para Notebooks
      - name: Instalar dependencias üì¶
        run: |
          python -m pip install --upgrade pip
          # Instala dependencias del proyecto
          # [ADAPTAR] Usa el comando apropiado para tu proyecto
          pip install -r requirements.txt # O requirements-dev.txt, etc.
          # poetry install --with dev
          # hatch env create && hatch run ...

          # Instala dependencias ESPEC√çFICAS para ejecutar notebooks y hacer linting (si aplica)
          # [ADAPTAR] A√±ade aqu√≠ TODAS las librer√≠as que tus notebooks importan + jupyter + nbconvert + nbqa + ruff
          pip install jupyter nbconvert ipykernel matplotlib pandas seaborn scikit-learn nbqa ruff
        shell: bash

      # 5. (Opcional) Linting y Formateo de Notebooks con nbqa + Ruff
      # nbqa permite correr herramientas como Ruff sobre el c√≥digo DENTRO de los notebooks.
      - name: Verificar formato con Ruff (v√≠a nbqa) ‚ú®
        # [ADAPTAR] Descomenta/elimina si no quieres verificar formato
        run: nbqa ruff format --check notebooks/ # [ADAPTAR] Ruta a notebooks
        shell: bash

      - name: Lint con Ruff (v√≠a nbqa) ‚ú®
        # [ADAPTAR] Descomenta/elimina si no quieres hacer linting
        run: nbqa ruff check notebooks/ # [ADAPTAR] Ruta a notebooks
        shell: bash

      # 6. Ejecutar TODOS los Notebooks
      # Usa 'find' para localizar todos los .ipynb y 'nbconvert' para ejecutarlos.
      # '--execute' corre el notebook de principio a fin.
      # '--to notebook' simplemente sobreescribe el notebook con la salida (o crea uno nuevo si no usas --inplace).
      # '--inplace' modifica el notebook original (¬°CUIDADO! Puede generar diffs grandes si las salidas cambian).
      # '--allow-errors' permitir√≠a que el paso termine con √©xito aunque un notebook falle (NO RECOMENDADO para CI).
      # '--ExecutePreprocessor.timeout=600' establece un timeout en segundos (ej: 10 minutos) por notebook.
      - name: Ejecutar notebooks con nbconvert üöÄ
        run: |
          find notebooks/ -name '*.ipynb' -print0 | xargs -0 -n 1 jupyter nbconvert --to notebook --execute \
            --inplace \
            --ExecutePreprocessor.timeout=600 \
            --ExecutePreprocessor.kernel_name=python3 # Asegura usar el kernel correcto
        shell: bash
        # [ADAPTAR] Ajusta la ruta 'notebooks/', el timeout y el kernel_name.
        # Considera NO usar '--inplace' y usar '--output-dir=executed_notebooks/' para guardar
        # los notebooks ejecutados en otro lugar y evitar cambios en el repo si las salidas cambian.
        # Si un notebook falla, este comando fallar√° y el job de CI fallar√° (¬°eso es bueno!).

      # 7. (Opcional - Avanzado) Verificar si hay salidas grandes en Git diff
      # Este paso intenta detectar si accidentalmente se commitearon notebooks con salidas muy grandes
      # despu√©s de la ejecuci√≥n (si no usaste --inplace o si limpiaste las salidas antes del commit).
      # Puede ser complejo de ajustar correctamente.
      # - name: Verificar outputs grandes en diff üîç
      #   run: |
      #     git diff --stat HEAD^ HEAD -- notebooks/**/*.ipynb # [ADAPTAR] Ruta
      #     # A√±ade l√≥gica aqu√≠ para fallar si el diff es demasiado grande o si detecta ciertos patrones.
      #     # echo "Revisar manualmente si hay outputs grandes commiteados en notebooks."
      #   shell: bash

Explicaci√≥n y Puntos Clave:

    Triggers (on:): El workflow se ejecuta en push/PR a las ramas principales, pero solo si cambian archivos dentro de notebooks/ o el propio workflow. Esto evita ejecuciones innecesarias. ¬°Adapta las ramas y la ruta!
    Dependencias: Es crucial instalar no solo las dependencias de tu proyecto (requirements.txt / pyproject.toml), sino tambi√©n jupyter, nbconvert, ipykernel y todas las librer√≠as que los notebooks importan (pandas, matplotlib, seaborn, sklearn, etc.). ¬°Aseg√∫rate de listarlas todas!
    Linting/Formato (Opcional): Usar nbqa con ruff (o black, flake8) es una buena pr√°ctica para mantener limpio el c√≥digo dentro de las celdas.
    Ejecuci√≥n (nbconvert --execute): Este es el n√∫cleo. Ejecuta cada notebook. Si alguna celda lanza una excepci√≥n, nbconvert fallar√° y, por lo tanto, el job de CI fallar√°, alert√°ndote del problema.
        --inplace: Conveniente pero peligroso. Modifica los archivos originales. Si las salidas cambian (gr√°ficos, dataframes impresos), generar√° un git diff grande. Generalmente, 
        es mejor limpiar las salidas (jupyter nbconvert --ClearOutputPreprocessor.enabled=True --inplace notebooks/*.ipynb) antes de commitear, y no usar --inplace en CI, sino --output-dir para verificar solo la ejecuci√≥n.
        Pero para un test simple de "corre o no corre", --inplace en CI puede ser suficiente (asumiendo que no commiteas las salidas).
        timeout: ¬°Importante! Evita que un notebook colgado bloquee tu CI indefinidamente. Ajusta el valor seg√∫n tus notebooks m√°s largos.
        kernel_name: Aseg√∫rate de que coincida con el kernel que tus notebooks esperan (python3 es com√∫n).
    Testing de Salidas: Este workflow no valida que las salidas (gr√°ficos, resultados num√©ricos) sean correctas, solo que el c√≥digo se ejecute. Para validar salidas se necesitan t√©cnicas m√°s avanzadas (ej: pytest-nbval, comparar salidas con versiones "doradas", aserciones dentro del notebook).

Adapta esta plantilla a las necesidades y complejidad de tus notebooks. ¬°Es un buen primer paso para asegurar que no se rompan silenciosamente!